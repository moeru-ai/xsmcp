---
title: Tools
description: Enable LLMs to perform actions through your server
---

<Callout>
  With [xsSchema](https://xsai.js.org/docs/packages-top/xsschema), the `parameters` here can support multiple libraries such as Zod, Valibot, ArkType, Effect Schema, Sury... at the same time.
</Callout>

## client.listTools

```ts
import { createClient } from '@xsmcp/server-shared'
import { createHttpTransport } from '@xsmcp/client-http'

const client = createClient({
  name: 'example-client',
  version: '1.0.0',
  transport: createHttpTransport({ url: 'http://localhost:3000/mcp' }),
})

await client.listTools()
```

## client.callTool

```ts
import { createClient } from '@xsmcp/server-shared'
import { createHttpTransport } from '@xsmcp/client-http'

const client = createClient({
  name: 'example-client',
  version: '1.0.0',
  transport: createHttpTransport({ url: 'http://localhost:3000/mcp' }),
})

await client.callTool('add', { a: 1, b: 1 })
await client.callTool('echo', { message: 'Hello, World!' })
await client.callTool('getTinyImage', {})
```

## integration with [xsAI](https://xsai.js.org) (experimental)

> This feature is yet to be tested and feedback is welcome.

### Library

```ts
import type { AudioPart, ImagePart, TextPart, Tool as XSAITool } from '@xsai/shared-chat'
import type { Client } from '@xsmcp/client-shared'
import type { CallToolResult } from '@xsmcp/shared'

import { rawTool } from '@xsai/tool'

const toXSAIContent = (contents: CallToolResult['content']): (AudioPart | ImagePart | TextPart)[] =>
  // eslint-disable-next-line array-callback-return
  contents.map((content) => {
    switch (content.type) {
      case 'audio':
        return {
          input_audio: {
            data: content.data,
            format: content.mimeType === 'audio/wav'
              ? 'wav'
              // TODO: fallback
              : 'mp3',
          },
          type: 'input_audio',
        } satisfies AudioPart
      case 'image':
        return {
          image_url: { url: content.data },
          type: 'image_url',
        } satisfies ImagePart
      case 'resource':
        return {
          text: ('text' in content.resource
            ? content.resource.text
            // TODO: fallback
            : content.resource.blob
          ),
          type: 'text',
        } satisfies TextPart
      case 'text':
        return {
          text: content.text,
          type: 'text',
        } satisfies TextPart
    }
  })

export const getTools = async (client: Client): Promise<XSAITool[]> =>
  client
    .listTools()
    .then(({ tools }) => tools.map(tool => rawTool({
      description: tool.description,
      execute: async params => client.callTool(tool.name, params as Record<string, unknown>)
        // eslint-disable-next-line sonarjs/no-nested-functions
        .then(result => toXSAIContent(result.content)),
      name: tool.name,
      parameters: tool.inputSchema,
    })))
```

### Usage

```ts
import { createHttpTransport } from '@xsmcp/client-http'
import { createClient } from '@xsmcp/server-shared'

import { getTools } from './get-tools'

const client = createClient({
  name: 'example-client',
  transport: createHttpTransport({ url: 'http://localhost:3000/mcp' }),
  version: '1.0.0',
})

const mcpTools = await client.listTools()

const result = await streamText({
  baseURL: 'http://localhost:11434/v1/',
  messages: [{
    content: 'What is the weather in Brooklyn, New York?',
    role: 'user',
  }],
  model: 'gemma3',
  onFinish: async () => await client.close(),
  tools: await getTools(client),
})
```
